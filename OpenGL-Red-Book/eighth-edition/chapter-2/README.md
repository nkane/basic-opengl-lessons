# Shader Fundamentals

### Shaders and OpenGL
Modern OpenGL rendering pipeline relies on using shaders to process data passed to it. Shaders, whether for OpenGL or any other graphics API, are usually
written in a specialized programming language. For OpenGL, the standard is the OpenGL Shading Language (GLSL). GLSL is a programming language designed
specially for graphics - it is similiar to the C programming language. 

### OpenGL's Programmable Pipeline
OpenGL Version 4.3's graphical pipeline contains four processing stages, plus a compute stage, each of which are control by providing a shader:

1. The Vertex Shader stage receives vertex data that is specified in a vertex-buffer object, procecssing each vertex separately. This stage is mandatory for
   all OpenGL programs and must have a shader bound to it.

2. The Tesselation shading stage is an optional stage that generates additional geometry within the OpenGL pipeline, as compared to having the application
   specify each geometric primitive explicity. This stage, if activated, receives the output of the vertex shading stage, and does further processing of the
   received vertices.

3. The Geometry shading stage is an optional stage that can modify entire geometric primitives within the OpenGL pipeline. This stage operates on individual
   geometric primitives allowing each to be modified. In this stage, the program might generate more geometry from the input primitive, change the type of
   geometric primitive (e.g., converting triangles to lines), or discarding the geometry altogether. If activated, geometry shading receives its input either
   after vertex shading has completed processing the vertices of a geometric primitive, or from the primitives generated from the tessellation shading stage,
   if it has been enabled. 

4. The last part of OpenGL shading pipeline is the Fragment shading stage. This stage processes the individual fragments (or samples, if sample-shading mode
   is enabled) generated by OpenGL's rasterizer, and must have a shader bound to it. In this stage, a fragment's color and depth values are computed, and then
   sent for further processing in the fragment-testing and blending parts of the pipeline.

5. The Compute shading stage is not part of the graphical pipeline as the stages above; however, it stands on its own as the only stage in a program. A compute
   shader processes generic work items, driven driven by an application-chosen range, rather than by graphical inputs like vertices and fragments. Compute
   shaders can process buffers created and consumed by other shader programs in an application. This includes framebuffer post-processing effects, or really
   anything. 

Shaders are like a function call - data is passed in, processed, and passed back out. In C for example, this can either be done using global variables, or
arguments to the function. GLSL is a bit different than these programs - each shader appears to be a small C program, in that it has an entry point function
named main(); however, GLSL's main() function does not take any arguments to the function. Instead, all data going into and out of a shader stage are passed
using special global variables in the shader. For example:

```GSLS
#version 330 core

in vec4 vPosition;
in vec4 vColor;

out vec4 color;

uniform mat4 ModelViewProjectionMatrix;

void
main()
{
	color = vColor;
	gl_Position = ModelViewProjectionMatrix * vPosition;
}

```
